# 2024 spring 数据结构与算法B 题目汇总

## assignment 1

### 20742: 泰波拿契數

http://cs101.openjudge.cn/practice/20742/

```python
nums = [0 for _ in range(31)]
nums[0] = 0
nums[1] = 1
nums[2] = 1
for i in range(3,31):
    nums[i] = nums[i-3] + nums[i-2] + nums[i-1]
print(nums[int(input())])
```



### 58A. Chat room

greedy/strings, 1000, http://codeforces.com/problemset/problem/58/A



```python
a = "hello"
b = input()
j = 0
i = 0
while True:
    if j == len(b):
        print('NO')
        break
    if a[i] == b[j]:
       i += 1
       j += 1
       if i == 5:
           print('YES')
           break
       else:
           continue
    else:
        j += 1
```



### 118A. String Task

implementation/strings, 1000, http://codeforces.com/problemset/problem/118/A



```python
vowels = ['A','a','O','o','Y','y','E','e','U','u','I','i']
st = input()
new_st = ''
for i in st:
    if i in vowels:
        continue
    else:
        if i.isupper():
            i = i.lower()
        new_st += '.'
        new_st += i
print(new_st)

```

### 22359: Goldbach Conjecture

http://cs101.openjudge.cn/practice/22359/



```python
is_prime = [True for _ in range(10001)]
is_prime[0] = False
is_prime[1] = False
for i in range(2,10001):
    if is_prime[i]:
        for j in range(i*i,10001,i):
            is_prime[j] = False
a = int(input())
for A in range(2,a//2+1):
    B = a - A
    if is_prime[A] and is_prime[B]:
        print(A,B)
        break
```

### 23563: 多项式时间复杂度

http://cs101.openjudge.cn/practice/23563/



```python
lis1 = list(input().split('+'))
re = 0
for i in range(len(lis1)):
    lis = list(lis1[i].split('^'))
    if lis[0] == '0n':
        continue
    if int(lis[1]) > re:
        re = int(lis[1])
print(f'n^{re}')

```



### 24684: 直播计票

http://cs101.openjudge.cn/practice/24684/

```python
maa = 0
results = [0 for i in range(100001)]
votes = list(map(int,input().split()))
for i in votes:
    results[i] += 1
    if maa < results[i]:
        maa = results[i]
re = []
for i in range(100001):
    if results[i] == maa:
        re.append(i)
for m in range(len(re)):
    print(re[m],end=' ')

```

## assignment2

### 27653: Fraction类

http://cs101.openjudge.cn/2024sp_routine/27653/



```python
from math import gcd
class Fraction:
    def __init__(self,top,bottom):
        self.num = top
        self.den = bottom

    def __str__(self):
        return str(self.num) + '/' + str(self.den)

    def show(self):
        print(self.num, '/', self.den)

    def __add__(self, other):
        newnum = self.num * other.den + other.num * self.den
        newden = self.den * other.den
        common = gcd(newnum,newden)
        return Fraction(newnum//common,newden//common)

    def __eq__(self, other):
        firstnum = self.num * other.den
        secondnum = self.den * other.num
        return firstnum == secondnum
        # 这段本题不需要

a, b, c, d = map(int,input().split())
f1 = Fraction(a,b)
f2 = Fraction(c,d)
f3 = f1 + f2
print(f3)

```

### 04110: 圣诞老人的礼物-Santa Clau’s Gifts

greedy/dp, http://cs101.openjudge.cn/practice/04110



```python
#2300011184
n,w = map(int,input().split())
candies = {}
for _ in range(n):
    candy,weight = map(int,input().split())
    value = candy/weight
    candies[(candy,weight)] = value
candies = dict(sorted(candies.items(),key=lambda x:x[1],reverse=True))
total_weight = 0
result = 0
for (candy,weight),value in candies.items():
    total_weight += weight
    if total_weight < w:
        result += candy
    else:
        total_weight -= weight
        result += (w-total_weight)*value
        break
print(f'{result:.1f}')

```

### 18182: 打怪兽

implementation/sortings/data structures, http://cs101.openjudge.cn/practice/18182/



```python
#2300011184
nCases = int(input())
for _ in range(nCases):
    n,m,b = map(int,input().split())
    dic = {}
    for i in range(n):
        t,x = map(int,input().split())
        if t not in list(dic.keys()):
            dic[t] = [x]
        else:
            dic[t].append(x)
    dic=dict(sorted(dic.items(),key=lambda x:x[0]))
    for j in list(dic.keys()):
        dic[j].sort(reverse=True)
        for l in range(m):
            if l >len(dic[j])-1:
                break
            b -= dic[j][l]
        if b <= 0:
            print(j)
            break
    if b > 0:
        print('alive')
    

```

### 230B. T-primes

binary search/implementation/math/number theory, 1300, http://codeforces.com/problemset/problem/230/B



```python
n = int(input())
result = []
nums=input()
nums_list=[int(x) for x in nums.split()]
 
def prime(n):
        seive = [True]*(n+1)
        prime_list = []
        for i in range(2,n+1):
                if seive[i]:
                        prime_list.append(i)
                        for u in range(i,n+1,i):
                              seive[u] = False
        return set(prime_list)
 
primes=prime(1000000)
 
 
for i in range(n):
        count = 0
        num = nums_list[i]
        num_ = num ** 0.5
        if num == 1:
                result.append('NO')
                continue
        if num_ % 1 == 0 :
                if num_ in primes:
                        result.append('YES')
                else:
                        result.append('NO')
        else:
                result.append('NO')
for i in range(n):
        print(result[i])

```

### 1364A. XXXXX

brute force/data structures/number theory/two pointers, 1200, https://codeforces.com/problemset/problem/1364/A



```python
t = int(input())
for _ in range(t):
    n, x = map(int, input().split())
    array = list(map(int, input().split()))
    sum_array = sum(array)
    sblist=[]
    if sum_array % x != 0:
        print(n)
    else:
        for i in range(n):
            if array[i] % x != 0:
                i1 = i+1
                break
        for m in range(1,n+1):
            if array[-m] % x !=0:
                i2 = m
                break
        for j in range(n):
            if array[i] % x != 0:
                sblist.append(1)
        if sum(sblist) == 0:
            print(-1)
        else:
            print(max(n-i1,n-i2))# 

```

### 18176: 2050年成绩计算

http://cs101.openjudge.cn/practice/18176/



```python
seive = [True]*100001
seive[1] = False
for i in range(2,10001):
    if seive[i]:
        for j in range(i*2,10001,i):
            seive[j] = False
def is_Tprime(n):
    n1 = n**0.5
    if n1-(n1//1) != 0:
        return False
    else:
        return seive[int(n1)]

ans = []
m,n = map(int,input().split())
for _ in range(m):
    score = list(map(int,input().split()))
    su = 0
    for x in score:
        if is_Tprime(x):
            su += x
    if su == 0:
        print(0)
    else:
        print(f'{su/len(score):.2f}')

```

## assignment3

### **02945: 拦截导弹**

http://cs101.openjudge.cn/practice/02945/



```python
k = int(input())
mis = list(map(int,input().split()))
dp = [1 for _ in range(k+1)]
for j in range(1,k):
    for i in range(j):
        if mis[i] >= mis[j]:
            dp[j] = max(dp[j],dp[i] + 1)
print(max(dp))

```

### **04147:汉诺塔问题(Tower of Hanoi)**

http://cs101.openjudge.cn/practice/04147



```python
def move_tower(height,frompole,withpole,topole):
    if height >= 1:
        move_tower(height-1,frompole,topole,withpole)
        move_disk(height,frompole,topole)
        move_tower(height-1,withpole,frompole,topole)
def move_disk(disk,frompole,topole):
    print(f'{disk}:{frompole}->{topole}')
height,frompole,withpole,topole = map(str,input().split())
move_tower(int(height),frompole,withpole,topole)

```

### **03253: 约瑟夫问题No.2**

http://cs101.openjudge.cn/practice/03253



```python
while True:
    n,p,m = map(int,input().split())
    if n == 0 and p == 0 and m == 0:
        break
    flag = p
    num = 1
    ans = 0
    test = [True for _ in range(n+1)]
    res = []
    while True:
        # print(flag,ans,num,res)
        flag += 1
        if flag > n:
            flag %= n
        if test[flag]:
            num += 1
            if num == m:
                num = 0
                res.append(flag)
                ans += 1
                test[flag] = False
                if ans == n :
                    break
            continue
        elif not test[flag]:
            continue
    for i in range(n-1):
        print(res[i],end = ',')
    print(res[n-1])

```

### **21554:排队做实验 (greedy)v0.2**

http://cs101.openjudge.cn/practice/21554



```python
from collections import defaultdict
index = defaultdict(list)
n = int(input())
lis = list(map(int,input().split()))
for i in range(n):
    index[lis[i]].append(i+1)
lis.sort()
ans = []
suu = 0
# print(index)
merge = []
for i in range(n):
    if lis[i] in merge:
        continue
    merge.append(lis[i])
    index[lis[i]].sort()
    for j in range(len(index[lis[i]])):
        ans.append(index[lis[i]][j])
        suu += (n-i-1)*lis[i]
        suu -= lis[i]*j
# print(ans)
for _ in range(n-1):
    print(ans[_],end=' ')
print(ans[n-1])
res = suu/n
print(f'{res:.2f}')

```

### **19963:买学区房**

http://cs101.openjudge.cn/practice/19963



```python
from math import sqrt
n = int(input())
pairs = [i[1:-1] for i in input().split()]
dis = [ sum(map(int,i.split(','))) for i in pairs]
pri = list(map(int,input().split()))

for i in range(n):
    dis[i] = dis[i]/pri[i]
new_dis = sorted(dis)
new_pri = sorted(pri)
if n%2 != 0:
    mid_dis = new_dis[(n-1)//2]
    mid_pri = new_pri[(n-1)//2]
else:
    mid_dis = (new_dis[n//2-1]+new_dis[n//2])/2
    mid_pri = (new_pri[n//2-1]+new_pri[n//2])/2

ans = 0
for i in range(n):
    if dis[i] > mid_dis and pri[i] < mid_pri:
        ans += 1
print(ans)

```

### **27300: 模型整理**

http://cs101.openjudge.cn/practice/27300



```python
from collections import defaultdict

def s_dic(list):
    M_lis = []
    B_lis = []
    for i in range(len(list)):
        if list[i][-1] == 'M':
            if '.' in list[i]:
                M_lis.append(float(list[i][:-1]))
            else:
                M_lis.append(int(list[i][:-1]))
        else:
            if '.' in list[i]:
                B_lis.append(float(list[i][:-1]))
            else:
                B_lis.append(int(list[i][:-1]))
    M_lis.sort()
    for k in range(len(M_lis)):
        M_lis[k] = str(M_lis[k]) + 'M'
    B_lis.sort()
    for l in range(len(B_lis)):
        B_lis[l] = str(B_lis[l]) + 'B'
    return M_lis + B_lis


n = int(input())
models = defaultdict(list)
for _ in range(n):
    model = list(map(str,input().split('-')))
    models[model[0]].append(model[1])
key_lis = sorted(list(models.keys()))
for i in key_lis:
    models[i] = s_dic(models[i])
for i in key_lis:
    print(i,end=': ')
    for j in range(len(models[i])-1):
        print(models[i][j],end=', ')
    print(models[i][len(models[i])-1])

```

## assignment4

### 05902: 双端队列

http://cs101.openjudge.cn/practice/05902/



思路：用deque自带的功能实现



代码

```python
from collections import deque

t = int(input())
for _ in range(t):
    do_list = deque([])
    n = int(input())
    for __ in range(n):
        a,b = map(int,input().split())
        if a == 1:
            do_list.append(b)
        else:
            if b == 0:
                do_list.popleft()
            else:
                do_list.pop()
    if do_list:
        print(*do_list)
    else:
        print('NULL')

```



### 02694: 波兰表达式

http://cs101.openjudge.cn/practice/02694/



思路：用栈写了一遍，比上个学期的代码精简了不少



代码

```python
op = ['+','-','*','/']
ex = list(map(str,input().split()))
stack = []
while ex:
    a = ex.pop(-1)
    if a in op:
        b = float(stack.pop(-1))
        c = float(stack.pop(-1))
        if a == '+':
            stack.append(b+c)
        elif a == '-':
            stack.append(b-c)
        elif a == '*':
            stack.append(b*c)
        else:
            stack.append(b/c)
    else:
        stack.append(float(a))
print(f'{stack[0]:.6f}')

```



### 24591: 中序表达式转后序表达式

http://cs101.openjudge.cn/practice/24591/



思路：按照课件给的算法写的，不得不说自己从头开始想估计得写上两天（）



代码

```python
def infix_to_profix(expression):
    pro = {'+':1,'-':1,'*':2,'/':2}
    stack = []
    profix = []
    number = ''
    for char in expression:
        if char.isnumeric() or char =='.':
            number += char
        else:
            if number:
               num = float(number)
               profix.append(int(num) if num.is_integer() else num)
               number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and pro[char] <= pro[stack[-1]]:
                    profix.append(stack.pop())
                stack.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    profix.append(stack.pop())
                stack.pop()
    if number:
        num = float(number)
        profix.append(int(num) if num.is_integer() else num)
    while stack:
        profix.append(stack.pop())
    return ' '.join(str(x) for x in profix)

n = int(input())
for _ in range(n):
    expression = input()
    print(infix_to_profix(expression))
```



### 22068: 合法出栈序列

http://cs101.openjudge.cn/practice/22068/



思路：一开始感觉比较迷惑。实际上是依次判断当前元素和栈顶元素，匹配的就弹出去，最后匹配不上就说明有问题



代码

```python
def is_valid(origin,output):
    if len(origin) != len(output):
        return False
    stack = []
    bank = list(origin)
    for char in output:
        while (not stack or stack[-1] != char) and bank:
            stack.append(bank.pop(0))
        if not stack or stack[-1] != char:
            return False
        stack.pop()
    return True

origin = input().strip()
while True:
    try:
        output = input().strip()
        if is_valid(origin,output):
            print('YES')
        else:
            print('NO')
    except EOFError:
        break# 

```

### 06646: 二叉树的深度

http://cs101.openjudge.cn/practice/06646/

思路：是个模板题，按照一般的建树的思路写就可以

代码

```python
class Treenode:
    def __init__(self):
        self.left = None
        self.right = None

def depth_tree(node):
    if node is None:
        return 0
    return max(depth_tree(node.left),depth_tree(node.right)) + 1

n = int(input())
nodes = [Treenode() for x in range(n)]

for i in range(n):
    left_index,right_index = map(int,input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index-1]
    if right_index != -1:
        nodes[i].right = nodes[right_index-1]

depth = depth_tree(nodes[0])
print(depth)

```

### 02299: Ultra-QuickSort

http://cs101.openjudge.cn/practice/02299/



思路：归并排序，按照归并排序的标准方法写+算一下操作次数



代码

```python
def merge_sort(lis):
    if len(lis) <= 1:
        return lis, 0
    mid = len(lis)//2
    left,inv_left = merge_sort(lis[:mid])
    right,inv_right = merge_sort(lis[mid:])

    merged,inv_merge = merge(left,right)

    return merged,inv_merge + inv_left + inv_right

def merge(left,right):
    merged = []
    inv_count = 0
    i,j = 0,0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            inv_count += len(left) - i

    merged += left[i:]
    merged += right[j:]

    return merged, inv_count

while True:
    n = int(input())
    if n == 0:
        break

    lis = []
    for _ in range(n):
        lis.append(int(input()))
    new_lis,res = merge_sort(lis)
    print(res)
```

## assignment5

### 27638: 求二叉树的高度和叶子数目

http://cs101.openjudge.cn/practice/27638/



思路：树的例题，建好树用递归求就好了



代码

```python
class Treenode:
    def __init__(self):
        self.left = None
        self.right = None

def tree_height(node):
    if node is None:
        return -1
    return max(tree_height(node.left),tree_height(node.right)) + 1

def count_leaves(node):
    if node is None:
        return 0
    if node.left is None and node.right is None:
        return 1
    return count_leaves(node.left) + count_leaves(node.right)

n = int(input())
nodes = [Treenode() for x in range(n)]
has_parent = [False for _ in range(n)]

for i in range(n):
    left_index,right_index = map(int,input().split())
    if left_index != -1:
        nodes[i].left = nodes[left_index]
        has_parent[left_index] = True
    if right_index != -1:
        nodes[i].right = nodes[right_index]
        has_parent[right_index] = True

root_index = has_parent.index(False)
root = nodes[root_index]
height = tree_height(root)
leaves = count_leaves(root)

print(height,leaves)

```

### 24729: 括号嵌套树

http://cs101.openjudge.cn/practice/24729/



思路：很正常的建树和递归思路，因为写类的时候用的列表所以后面要用extend



代码

```python
class TreeNode:
    def __init__(self,node):
        self.node = node
        self.children = []

def parse_tree(exp):
    stack = []
    node = None
    for char in exp:
        if char.isalpha():
            node = TreeNode(char)
            if stack:
                stack[-1].children.append(node)
        elif char == '(':
            if node:
                stack.append(node)
                node = None
        elif char == ')':
            if stack:
                node = stack.pop()
    return node

def preorder(root):
    exp = [root.node]
    for child in root.children:
        exp.extend(preorder(child))
    return ''.join(exp)

def postorder(root):
    exp = []
    for child in root.children:
        exp.extend(postorder(child))
    exp.append(root.node)
    return ''.join(exp)

s = input().strip()
s = ''.join(s.split())
root = parse_tree(s)
if root:
    print(preorder(root))
    print(postorder(root))
```

### 02775: 文件结构''图”

http://cs101.openjudge.cn/practice/02775/



思路：本质上还是树，但是要区分子节点的类型，学着用字典写了一遍



代码

```python
def print_graph(node,indent = 0):
    prefix = '|     ' * indent
    print(prefix + node['name'])
    for dir in node['dirs']:
        print_graph(dir,indent + 1)
    for file in sorted(node['files']):
        print(prefix + file)

dataset = 1
datas = []
temp = []

while True:
    line = input()
    if line == '#':
        break
    elif line == '*':
        datas.append(temp)
        temp = []
    else:
        temp.append(line)
for data in datas:
    print(f'DATA SET {dataset}:')
    root = {'name':'ROOT','dirs':[],'files':[]}
    stack = [root]
    for line in data:
        if line[0] == 'd':
            dir = {'name':line,'dirs':[],'files':[]}
            stack[-1]['dirs'].append(dir)
            stack.append(dir)
        elif line[0] == 'f':
            stack[-1]['files'].append(line)
        else:
            stack.pop()
    print_graph(root)
    if dataset < len(datas):
        print()
    dataset += 1

```





### 25140: 根据后序表达式建立队列表达式

http://cs101.openjudge.cn/practice/25140/



思路：建树过程有点像波兰表达式，输出队列表达式用bfs



代码

```python
class TreeNode:
    def __init__(self,value):
        self.value = value
        self.left = None
        self.right = None

def prase_tree(exp):
    stack = []
    for char in exp:
        node = TreeNode(char)
        if char.isupper():
            node.right = stack.pop()
            node.left = stack.pop()
        stack.append(node)
    return stack[0]

def levelorder(root):
    queue = [root]
    exp = []
    while queue:
        node = queue.pop(0)
        exp.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return exp

n = int(input())
for _ in range(n):
    s = input().strip()
    root = prase_tree(s)
    ans = levelorder(root)
    print(''.join(ans)[::-1])
```



### 24750: 根据二叉树中后序序列建树

http://cs101.openjudge.cn/practice/24750/



思路：用递归，按照根节点生成左子树和右子树建树，输出就简单了



代码

```python
class TreeNode:
    def __init__(self,value):
        self.value = value
        self.left = None
        self.right = None

def prase_tree(inorder,postorder):
    if not inorder or not postorder:
        return None

    root = postorder.pop()
    root_index = inorder.index(root)
    tree_root = TreeNode(root)

    tree_root.right = prase_tree(inorder[root_index+1:],postorder)
    tree_root.left = prase_tree(inorder[:root_index],postorder)

    return tree_root

def preorder(root):
    exp = []
    if root:
        exp.append(root.value)
        exp.append(preorder(root.left))
        exp.append(preorder(root.right))
    return ''.join(exp)

inorder = input()
postorder = input()

root = prase_tree(list(inorder),list(postorder))

print(preorder(root))

```

### 22158: 根据二叉树前中序序列建树

http://cs101.openjudge.cn/practice/22158/



思路：和上一个题基本上是一样的，读取数据的时候有点不同



代码

```python
class TreeNode:
    def __init__(self,value):
        self.value = value
        self.left = None
        self.right = None

def prase_tree(preorder,inorder):
    if not preorder or not inorder:
        return None

    rootnode = preorder.pop(0)
    root = TreeNode(rootnode)
    root_index = inorder.index(rootnode)

    root.left = prase_tree(preorder,inorder[:root_index])
    root.right = prase_tree(preorder,inorder[root_index+1:])

    return root

def postorder(root):
    exp = []
    if root:
        exp.append(postorder(root.left))
        exp.append(postorder(root.right))
        exp.append(root.value)
    return ''.join(exp)

while True:
    try:
        preorder = list(input())
        inorder = list(input())
        root = prase_tree(preorder,inorder)
        print(postorder(root))
        continue
    except EOFError:
        break


```

## assignment6

### 22275: 二叉搜索树的遍历

http://cs101.openjudge.cn/practice/22275/



思路：利用二叉搜索树优良的性质从根节点开始分成左子树和右子树并分别递归



代码

```python
def postorder(preorder):
    if not preorder:
        return []
    root = preorder[0]
    left = [x for x in preorder if x < root]
    right = [x for x in preorder if x > root]
    return postorder(left) + postorder(right) + [root]

n = int(input())
preorder = list(map(int,input().split()))
postorder = postorder(preorder)
for i in range(n-1):
    print(postorder[i],end = ' ')
print(postorder[n-1])

```



### 05455: 二叉搜索树的层次遍历

http://cs101.openjudge.cn/practice/05455/



思路：用insert方法建一个二叉树，用bfs实现层次遍历

 

代码

```python
class TreeNode:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None

def insert(node,value):
    if node is None:
        return TreeNode(value)
    if value < node.val:
        node.left = insert(node.left,value)
    elif value > node.val:
        node.right = insert(node.right,value)
    return node

def levelorder(root):
    deque = [root]
    traversal = []
    while deque:
        node = deque.pop(0)
        traversal.append(node.val)
        if node.left:
            deque.append(node.left)
        if node.right:
            deque.append(node.right)
    return traversal

numbers = list(map(int,input().strip().split()))
numbers = list(dict.fromkeys(numbers))
root = None

for num in numbers:
    root = insert(root,num)
ans = levelorder(root)
print(' '.join(map(str,ans)))

```

### 04078: 实现堆结构

http://cs101.openjudge.cn/practice/04078/

练习自己写个BinHeap。当然机考时候，如果遇到这样题目，直接import heapq。手搓栈、队列、堆、AVL等，考试前需要搓个遍。



思路：按照标准写法把二叉堆搓一遍，为笔试准备的话感觉记忆量还是很大的



代码

```python
class BinHeap:
    def __init__(self):
        self.heaplist = [0]
        self.CurrentSize = 0

    def insert(self,num):
        self.heaplist.append(num)
        self.CurrentSize = self.CurrentSize + 1
        self.percup(self.CurrentSize)

    def percup(self,i):
        while i // 2 > 0:
            if self.heaplist[i // 2] > self.heaplist[i]:
                tmp = self.heaplist[i]
                self.heaplist[i] = self.heaplist[i // 2]
                self.heaplist[i // 2] = tmp
            i = i // 2

    def perdowm(self,i):
        while i * 2 <= self.CurrentSize:
            mc = self.minchild(i)
            if self.heaplist[i] > self.heaplist[mc]:
                tmp = self.heaplist[i]
                self.heaplist[i] = self.heaplist[mc]
                self.heaplist[mc] = tmp
            i = mc

    def minchild(self,i):
        if i * 2 + 1 > self.CurrentSize:
            return i * 2
        else:
            if self.heaplist[i * 2] < self.heaplist[i * 2 + 1]:
                return i * 2
            else:
                return i * 2 + 1

    def delmin(self):
        tmp = self.heaplist[1]
        self.heaplist[1] = self.heaplist[self.CurrentSize]
        self.CurrentSize = self.CurrentSize - 1
        self.heaplist.pop()
        self.perdowm(1)
        return tmp

n = int(input())
binheap = BinHeap()
for _ in range(n):
    op = input()
    if op[0] == '1':
        type,num = map(int,op.split())
        binheap.insert(num)
    else:
        print(binheap.delmin())
```



### 22161: 哈夫曼编码树

http://cs101.openjudge.cn/practice/22161/



思路：哈夫曼大礼包，感觉理解起来比二叉堆容易一些但是代码量更大，需要注意找权值最小的两个字母的时候用heap是比较方便的



代码

```python
import heapq

class Node:
    def __init__(self,freq,char = None):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.freq == other.freq:
            return self.char < other.char
        return self.freq < other.freq

def build_huffman_tree(characters):
    heap = []
    for char,freq in characters.items():
        heapq.heappush(heap,Node(freq,char))

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(left.freq + right.freq)
        merged.left = left
        merged.right = right
        heapq.heappush(heap,merged)

    return heap[0]

def encode_huffman_tree(root):
    codes = {}

    def traverse(node,code):
        if node.char:
            codes[node.char] = code
        else:
            traverse(node.left,code + '0')
            traverse(node.right,code + '1')

    traverse(root,'')
    return codes

def huffman_encoding(codes,string):
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root,encoded_string):
    decoded = ''
    node = root
    for bit in encoded_string:
        if bit == '0':
            node = node.left
        else:
            node = node.right
        if node.char:
            decoded += node.char
            node = root
    return decoded

n = int(input())
characters = {}
for _ in range(n):
    letter,freq = input().split()
    characters[letter] = int(freq)

huffman_tree = build_huffman_tree(characters)
codes = encode_huffman_tree(huffman_tree)

strings = []
while True:
    try:
        line = input()
        if line:
            strings.append(line)
        else:
            break
    except EOFError:
        break
res = []
for string in strings:
    if string[0] in ('0','1'):
        res.append(huffman_decoding(huffman_tree,string))
    else:
        res.append(huffman_encoding(codes,string))
for r in res:
    print(r)

```



### 晴问9.5: 平衡二叉树的建立

https://sunnywhy.com/sfbj/9/5/359



思路：在二叉树的基础上增加了旋转的操作，对着题解理解了代码之后再自己写的，不敢想完全靠自己写的话要写多久



代码

```python
class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

class AVL:
    def __init__(self):
        self.root = None

    def insert(self,value):
        if not self.root:
            self.root = Node(value)
        else:
            self.root = self._insert(value,self.root)

    def _insert(self,value,node):
        if not node:
            return Node(value)
        else:
            if value < node.val:
                node.left = self._insert(value,node.left)
            else:
                node.right = self._insert(value,node.right)
        node.height = 1 + max(self.get_height(node.left),self.get_height(node.right))
        balance = self.get_balance(node)

        if balance > 1:
            if value < node.left.val:
                return self.rotate_right(node)
            else:
                node.left = self.rotate_left(node.left)
                return self.rotate_right(node)
        if balance < -1:
            if value > node.right.val:
                return self.rotate_left(node)
            else:
                node.right = self.rotate_right(node.right)
                return self.rotate_left(node)
        return node

    def get_height(self,node):
        if not node:
            return 0
        return node.height

    def get_balance(self,node):
        if not node:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)

    def rotate_left(self,z):
        y = z.right
        T2 = y.left
        y.left = z
        z.right = T2
        z.height = 1 + max(self.get_height(z.left),self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left),self.get_height(y.right))
        return y

    def rotate_right(self,z):
        y = z.left
        T2 = y.right
        y.right = z
        z.left = T2
        z.height = 1 + max(self.get_height(z.left),self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left),self.get_height(y.right))
        return y

    def preorder(self,node):
        if not node:
            return []
        return [node.val] + self.preorder(node.left) + self.preorder(node.right)

n = int(input().strip())
numbers = list(map(int,input().strip().split()))

avl = AVL()
for num in numbers:
    avl.insert(num)

print(' '.join(map(str,avl.preorder(avl.root))))

```

### 02524: 宗教信仰

http://cs101.openjudge.cn/practice/02524/



思路：写完上面的树之后感觉这个并查集格外顺眼，将信仰相同的两个人连到一个父节点，最后看有几个人的编号和自己相同，其他人都可以连到这些人



代码

```python
def find(x,fa):
    if fa[x] == x:
        return x
    else:
        return find(fa[x],fa)

def union(x,y,fa):
    fx = find(x,fa)
    fy = find(y,fa)
    if fx == fy:
        return
    fa[fx] = fy

case_num = 0
while True:
    n,m = map(int,input().split())
    if n == 0 and m == 0:
        break
    else:
        count = 0
        case_num += 1
        fa = [x for x in range(n)]
        for _ in range(m):
            x,y = map(int,input().split())
            union(x-1,y-1,fa)
        for i in range(n):
            if fa[i] == i:
                count += 1
        print(f'Case {case_num}: {count}')

```

## assignment7

### 27706: 逐词倒放

http://cs101.openjudge.cn/practice/27706/



思路：“开胃小菜”，直接翻译题目即可



代码

```python
lis = list(map(str,input().split()))
l = reversed(lis)
print(' '.join(l))

```

### 27951: 机器翻译

http://cs101.openjudge.cn/practice/27951/



思路：同样是直接翻译题目，用一下deque就好了



代码

```python
from collections import deque
m,n = map(int,input().split())
lis = list(map(int,input().split()))
d = deque([])
count = 0
for i in range(n):
    if lis[i] in d:
        continue
    else:
        count += 1
        if len(d) == m:
            d.popleft()
        d.append(lis[i])
print(count)

```

### 27932: Less or Equal

http://cs101.openjudge.cn/practice/27932/



思路：用bisect可以轻松解决，事实上他说“最小的”就说明如果能取得到就一定在这些数字里面，但是因为读题没读好在k=0的临界错了好多次，以后要多注意看变量的取值范围



代码

```python
import bisect

def solve(k,lis):
    if k == 0:
        if lis[0] == 1:
            return -1
        else:
            return 1
    for i in lis:
        a = bisect.bisect_right(lis, i)
        if a == k:
            return i
        elif a > k:
            return -1

n,k = map(int,input().split())
lis = list(map(int,input().split()))
lis.sort()
print(solve(k,lis))

```

### 27948: FBI树

http://cs101.openjudge.cn/practice/27948/



思路：（第一次无参考搓出来一棵树）感觉是一种简单的树，按照最简单的建树和模板化的输出就可以了



代码

```python
class Node:
    def __init__(self,type):
        self.type = type
        self.left = None
        self.right = None

def judge(string):
    if '1' not in string:
        return 'B'
    elif '0' not in string:
        return 'I'
    else:
        return 'F'

def prase_tree(string):
    if len(string) == 1:
        return Node(judge(string))
    mid = len(string)//2
    root = Node(judge(string))
    root.left = prase_tree(string[:mid])
    root.right = prase_tree(string[mid:])

    return root

def postorder(root):
    ans = []
    if root:
        ans.append(postorder(root.left))
        ans.append(postorder(root.right))
        ans.append(root.type)
    return ''.join(ans)

N = int(input())
string = input()
root = prase_tree(string)
print(postorder(root))

```

### 27925: 小组队列

http://cs101.openjudge.cn/practice/27925/



思路：发现了是要用多个列表来记录一些数据来实现“插入到小组中最后一位成员的后面”，虽然最后的时间也不是非常理想，绕明白了之后题目也不是特别困难



代码

```python
from collections import deque

group = {}
t = int(input())
for i in range(t):
    pe = list(map(str,input().split()))
    for p in pe:
        group[p] = i

stack = deque([])
test = [0 for _ in range(t)]
index = [0 for _ in range(t)]
while True:
    operation = input()
    if operation[0] == 'S':
        break
    elif operation[0] == 'D':
        a = stack.popleft()
        test[group[a]] -= 1
        print(a)
    else:
        op,a = operation.split()
        if test[group[a]] != 0:
            stack.insert(index[group[a]]+1,a)
            test[group[a]] += 1
            for i in range(t):
                if index[i] >= index[group[a]]:
                    index[i] += 1
        else:
            stack.append(a)
            index[group[a]] = len(stack) - 1
            test[group[a]] += 1

```



### 27928: 遍历树

http://cs101.openjudge.cn/practice/27928/



思路：建树的思路还是正常的，似乎有人提到用并查集（？但是在init里面用一个.children也是见过的用法，学习了一下遍历的思路



代码

```python
class Node:
    def __init__(self,val):
        self.val = val
        self.children = []


def traverse(root,nodes):
    if root.children == []:
        print(root.val)
        return
    pac = {root.val:root}
    for child in root.children:
        pac[child] = nodes[child]
    for value in sorted(pac.keys()):
        if value in root.children:
            traverse(pac[value],nodes)
        else:
            print(root.val)


n = int(input())
nodes = {}
has_parent = []
for i in range(n):
    nums = list(map(int,input().split()))
    nodes[nums[0]] = Node(nums[0])
    for num in nums[1:]:
        nodes[nums[0]].children.append(num)
        has_parent.append(num)
root = nodes[[value for value in nodes.keys() if value not in has_parent][0]]
traverse(root,nodes)

```

## assignment8

### 19943: 图的拉普拉斯矩阵

matrices, http://cs101.openjudge.cn/practice/19943/

请定义Vertex类，Graph类，然后实现



思路：

按照要求定义了两个类然后实现的

代码

```python
class Vertex:
    def __init__(self,key):
        self.id = key
        self.connectedto = {}

    def addNeighbor(self,nbr,weight = 0):
        self.connectedto[nbr] = weight

    def getConnectiongs(self):
        return self.connectedto.keys()

    def getId(self):
        return self.id

class Graph:
    def __init__(self):
        self.vertList = {}
        self.numVertices = 0

    def addVertex(self,key):
        self.numVertices = self.numVertices + 1
        newVertex = Vertex(key)
        self.vertList[key] = newVertex
        return newVertex

    def getVertex(self,n):
        if n in self.vertList:
            return self.vertList[n]
        else:
            return None

    def __contains__(self,n):
        return n in self.vertList

    def addEdge(self,f,t,weight = 0):
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
        self.vertList[f].addNeighbor(self.vertList[t])

    def getVertices(self):
        return self.vertList.keys()

    def __iter__(self):
        return iter(self.vertList.values())

def prase_matrix(n,edges):
    graph = Graph()
    for i in range(n):
        graph.addVertex(i)

    for edge in edges:
        a,b = edge
        graph.addEdge(a,b)
        graph.addEdge(b,a)

    matrix = []
    for Vertex in graph:
        row = [0]*n
        row[Vertex.getId()] = len(Vertex.getConnectiongs())
        for neighbor in Vertex.getConnectiongs():
            row[neighbor.getId()] = -1
        matrix.append(row)

    return matrix

n,m = map(int,input().split())
edges = []
for i in range(m):
    a,b = map(int,input().split())
    edges.append((a,b))
Matrix = prase_matrix(n,edges)
for row in Matrix:
    print(' '.join(map(str,row)))

```

### 18160: 最大连通域面积

matrix/dfs similar, http://cs101.openjudge.cn/practice/18160



思路：dfs例题，和上个学期用的思路是一样的



代码

```python
area = 0
def dfs(x,y,matrix):
    global area
    if matrix[x][y] == '.':
        return
    area += 1
    matrix[x][y] = '.'
    for i in range(8):
        nx,ny = x + di[i][0],y + di[i][1]
        dfs(nx,ny,matrix)


res = []
t = int(input())
di = [[-1,0],[-1,-1],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
for _ in range(t):
    area = 0
    ans = 0
    n,m = map(int,input().split())
    matr = [['.'] * (m + 2)]
    for i in range(n):
        matr.append(['.'] + list(input()) + ['.'])
    matr.append(['.'] * (m + 2))
    for i in range(1,n+1):
        for j in range(1,m+1):
            if matr[i][j] == 'W':
                area = 0
                dfs(i,j,matr)
                ans = max(ans,area)
    res.append(ans)
for i in range(t):
    print(res[i])

```

### sy383: 最大权值连通块

https://sunnywhy.com/sfbj/10/3/383



思路：定义vertex之后debug半天无果，学到了不一定要靠定义类做graph的题目



代码

```python
def max_weight(n,m,weights,edges):
    graph = [[] for _ in range(n)]
    for u,v in edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = [False]*n
    max_weight = 0

    def dfs(node):
        visited[node] = True
        total_weight = weights[node]
        for neighbor in graph[node]:
            if not visited[neighbor]:
                total_weight += dfs(neighbor)
        return total_weight

    for i in range(n):
        if not visited[i]:
            max_weight = max(max_weight,dfs(i))
    return max_weight

n,m = map(int,input().split())
weights = list(map(int,input().split()))
edges = []
for _ in range(m):
    u,v = map(int,input().split())
    edges.append((u,v))
print(max_weight(n,m,weights,edges))

```

### 03441: 4 Values whose Sum is 0

data structure/binary search, http://cs101.openjudge.cn/practice/03441



思路：先组前两列，把所有可能的和用字典带上出现次数存好，再判断后面两列，如果相加的相反数在字典的键里面就可以



代码

```python
n = int(input())
a = [0]*n
b = [0]*n
c = [0]*n
d = [0]*n
dic = {}

for _ in range(n):
    a[_],b[_],c[_],d[_] = map(int,input().split())

for i in range(n):
    for j in range(n):
        if a[i]+b[j] not in dic:
            dic[a[i]+b[j]] = 0
        dic[a[i]+b[j]] += 1

ans = 0
for i in range(n):
    for j in range(n):
        if -(c[i]+d[j]) in dic:
            ans += dic[-(c[i]+d[j])]

print(ans)

```



### 04089: 电话号码

trie, http://cs101.openjudge.cn/practice/04089/

Trie 数据结构可能需要自学下。



思路：

自学了trie的写法，这个题还是比较标准的

代码

```python
class Trienode:
    def __init__(self):
        self.child = {}

class Trie:
    def __init__(self):
        self.root = Trienode()

    def insert(self,nums):
        curnode = self.root
        for x in nums:
            if x not in curnode.child:
                curnode.child[x] = Trienode()
            curnode = curnode.child[x]
    def search(self,num):
        curnode = self.root
        for x in num:
            if x not in curnode.child:
                return 0
            curnode = curnode.child[x]
        return 1

t = int(input())
for _ in range(t):
    n = int(input())
    nums = []
    for __ in range(n):
        nums.append(str(input()))
    nums.sort(reverse = True)
    s = 0
    trie = Trie()
    for num in nums:
        s += trie.search(num)
        trie.insert(num)
    if s > 0:
        print('NO')
    else:
        print('YES')

```



### 04082: 树的镜面映射

http://cs101.openjudge.cn/practice/04082/



思路：自己完成这个题目仍然有困难所以学习了题解的代码，感觉这是一道很综合的题目，结合了上半学期学的字符串，队列和树的几乎所有知识点。自己的能力还需要提升



代码

```python
from collections import deque

class Treenode:
    def __init__(self,val):
        self.val = val
        self.children = []

def creat_node():
    return Treenode('')

def prase_tree(tmplist,index):
    node = creat_node()
    node.val = tmplist[index][0]
    if tmplist[index][1] == '0':
        index += 1
        child,index = prase_tree(tmplist,index)
        node.children.append(child)
        index += 1
        child,index = prase_tree(tmplist,index)
        node.children.append(child)
    return node,index

def print_tree(p):
    q = deque()
    s = deque()

    while p is not None:
        if p.val != '$':
            s.append(p)
        if len(p.children) > 1:
            p = p.children[1]
        else:
            p = None
    while s:
        q.append(s.pop())

    while q:
        p = q.popleft()
        print(p.val,end = ' ')

        if p.children:
            p = p.children[0]
            while p is not None:
                if p.val != '$':
                    s.append(p)
                if len(p.children) > 1:
                    p = p.children[1]
                else:
                    p = None
            while s:
                q.append(s.pop())

n = int(input())
tmplist = list(map(str,input().split()))

root,_ = prase_tree(tmplist,0)
print_tree(root)

```

## assignment9

### 04081: 树的转换

http://cs101.openjudge.cn/dsapre/04081/



思路：求出两个树的高度比较简单，难点是转换的过程。根据“左儿子右兄弟”，对第一个儿子递归建立左子树，后面往栈里面压，将倒数第一个元素连到倒数第二个元素的右边。



代码

```python
from collections import defaultdict

class Node:
    def __init__(self,val):
        self.val = val
        self.children = []

class TreeNode:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None

s = input()
dic = defaultdict(list)
dic[0].append(Node(0))
h1 = 0
pos = 0
for i in s:
    if i == 'd':
        pos += 1
        h1 += 1
        a = Node(pos)
        dic[h1].append(a)
        dic[h1-1][-1].children.append(a)
    else:
        h1 -= 1
h1 = max(dic.keys())

def prase_tree(a):
    root = TreeNode(a.val)
    b = a.children[0]
    if b.children:
        root.left = prase_tree(b)
    else:
        root.left = TreeNode(b.val)
    stack = [root,root.left]
    for i in a.children[1:]:
        if i.children:
            stack.append(prase_tree(i))
        else:
            stack.append(TreeNode(i.val))
        stack[-2].right = stack[-1]
    return root

def find(root):
    if not root:
        return -1
    return max(find(root.left)+1,find(root.right)+1)

root = prase_tree(dic[0][0])
h2 = find(root)

print(f'{h1} => {h2}')
```

### 08581: 扩展二叉树

http://cs101.openjudge.cn/dsapre/08581/



思路：比上一个题要简单一些，用一个栈记录当前走到了哪个字母，如果他的左儿子是空的就连上，反之则连到右边并且弹出栈的最后一个元素（它已经连满了），最后求中序后序都是公式化的东西了



这个题有一个我觉得很离奇的bug，在建树的时候必须要用一个a=node(i)，后面赋值的时候都用a，而不可以在后面写“stack[-1] = node(i)”等等，否则就会有一些点连不上，不知道是为什么（错误的代码也写在了最后）



代码

```python
class node:
    def __init__(self,id):
        self.id = id
        self.left = None
        self.right = None


s = input()
root = node(s[0])
stack = [root]
for i in s[1:]:
    a = node(i)
    if stack[-1].left is None:
        stack[-1].left = a
        if i != '.':
            stack.append(a)
    else:
        stack[-1].right = a
        stack.pop()
        if i != '.':
            stack.append(a)

def inorder(root):
    if root.id == '.':
        return ''
    return inorder(root.left) + root.id + inorder(root.right)

def postorder(root):
    if root.id == '.':
        return ''
    return postorder(root.left) + postorder(root.right) + root.id

print(inorder(root))
print(postorder(root))# 

# for i in s[1:]:
#     if stack[-1].left is None:
#         stack[-1].left = node(i)
#         if i != '.':
#             stack.append(node(i))
#     else:
#         stack[-1].right = node(i)
#         stack.pop()
#         if i != '.':
#             stack.append(node(i))

```



### 22067: 快速堆猪

http://cs101.openjudge.cn/practice/22067/



思路：比较麻烦的部分是如何判断有没有将最轻的猪弹出，这里多用一个m列表，它里面每次记录目前最轻的重量，目的是反映最轻的猪上面还有几只，弹出的时候最后面的元素一并弹出，这样如果最轻的猪被弹出，记录的重量也可以及时更新



代码

```python
stack = []
m = []
while True:
    try:
        op = input()
        if 'push' in op:
            a,weight = op.split()
            stack.append(int(weight))
            if not m:
                m.append(int(weight))
            else:
                m.append(min(int(weight),m[-1]))
        elif op == 'pop':
            if stack:
                stack.pop()
                if m:
                    m.pop()
        elif op == 'min':
            if stack:
                print(m[-1])
    except EOFError:
        break

```



### 04123: 马走日

dfs, http://cs101.openjudge.cn/practice/04123



思路：dfs例题，自己一遍过了，但是程序有点太慢（），参考了题解进行优化。

原先的问题在于判断是否走完的时候耗时太长，事实上只需要记录步数，步数等于格子数的时候自然就走完了。



代码

```python
di = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]


ans = 0
def dfs(x, y, can_visit, n, m,dep):
    global ans
    can_visit[x][y] = False
    if dep == n*m:
        ans += 1
        return
    for i in range(8):
        x1 = x + di[i][0]
        y1 = y + di[i][1]
        if x1 < 0 or y1 < 0 or x1 > (n - 1) or y1 > (m - 1):
            continue
        if can_visit[x1][y1]:
            dfs(x1, y1, can_visit, n, m,dep + 1)
            can_visit[x1][y1] = True


T = int(input())
for _ in range(T):
    ans = 0
    n, m, x, y = map(int, input().split())
    can_visit = [[True for _ in range(m)] for __ in range(n)]
    dfs(x, y, can_visit, n, m,1)
    print(ans)

```

### 28046: 词梯

bfs, http://cs101.openjudge.cn/practice/28046/



思路：参考了建图的方式，这是否是一种并查集（？后面bfs的思路就比较常规了，记录走过哪些然后依次弹出就可以了



代码

```python
from collections import deque

def prase_graph(words):
    graph = {}
    for word in words:
        for i in range(len(word)):
            pattern = word[:i] + '_' + word[i+1:]
            if pattern not in graph:
                graph[pattern] = []
            graph[pattern].append(word)
    return graph

def bfs(start,end,graph):
    queue = deque([(start,[start])])
    visited = set(start)

    while queue:
        word,path = queue.popleft()
        if word == end:
            return path
        for i in range(len(word)):
            pattern = word[:i] + '_' + word[i+1:]
            if pattern in graph:
                for neighbor in graph[pattern]:
                    if neighbor not in visited:
                        queue.append((neighbor,path + [neighbor]))
                        visited.add(neighbor)
    return None

n = int(input())
words = []
for ___ in range(n):
    words.append(input())
graph = prase_graph(words)
start,end = map(str,input().split())
res = bfs(start,end,graph)

if res:
    print(' '.join(res))
else:
    print('NO')

```



### 28050: 骑士周游

dfs, http://cs101.openjudge.cn/practice/28050/



思路：因为棋盘的扩大所以需要优化，具体操作是在dfs的时候每次先走邻居较少的格子，因为他们往往更靠近边缘，而先走完边缘会有助于找到较短的路径，毕竟只要有一条满足即可



代码

```python
di = [(1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1)]
def knight_tour(n,x,y,di):
    visited = [[False]*n for _ in range(n)]

    def can_vis(row,col):
        return  0 <= row <= n-1 and 0 <= col <= n-1 and not visited[row][col]

    def count_neighbors(row,col):
        cnt = 0
        for r,c in di:
            nx,ny = row + r,col + c
            if can_vis(nx,ny):
                cnt += 1
        return cnt

    def sort_moves(row,col):
        neighbor_counts = []
        for r,c in di:
            nx,ny = row +r,col + c
            if can_vis(nx,ny):
                count = count_neighbors(nx,ny)
                neighbor_counts.append((count,(nx,ny)))
        neighbor_counts.sort()
        sorted_moves = [move[1] for move in neighbor_counts]
        return sorted_moves

    visited[x][y] = True
    tour = [(x,y)]

    while len(tour) < n**2:
        cur_x,cur_y = tour[-1]
        sorted_next_moves = sort_moves(cur_x,cur_y)
        if not sorted_next_moves:
            return 'fail'
        next_x,next_y = sorted_next_moves[0]
        visited[next_x][next_y] = True
        tour.append((next_x,next_y))
    return 'success'

n = int(input())
x,y = map(int,input().split())
print(knight_tour(n,x,y,di))

```

## assignmentA

### 20743: 整人的提词本

http://cs101.openjudge.cn/practice/20743/



思路：维护两个堆，一个用来记录出现的字母，另一个用来记录每次遇到右括号的时候将多少字母倒过来，最后把所有字母连起来就是答案



代码

```python
s = input()
ans = ''
stack_letters = []
stack_nums = []

for i in s:
    if i != '(' and i != ')':
        stack_letters.append(i)
        if stack_nums:
            stack_nums = [x + 1 for x in stack_nums]
    if i == '(':
        stack_nums.append(0)
    if i == ')':
        tmp = []
        num = stack_nums.pop()
        for _ in range(num):
            tmp.append(stack_letters.pop())
        for __ in range(num):
            stack_letters.append(tmp[__])

for i in range(len(stack_letters)):
    ans += stack_letters[i]

print(ans)

```

### 02255: 重建二叉树

http://cs101.openjudge.cn/practice/02255/



思路：和根据前中序序列那个题一模一样的，把生成后序的函数写简单了一点



代码

```python
class node:
    def __init__(self,id):
        self.id = id
        self.left = None
        self.right = None

def prase_tree(preorder,inorder):
    if not preorder or not inorder:
        return None
    rootnode = preorder.pop(0)
    root = node(rootnode)
    root_id = inorder.index(rootnode)

    if inorder:
        root.left = prase_tree(preorder,inorder[:root_id])
        root.right = prase_tree(preorder,inorder[root_id+1:])

    return root

def postorder(root):
    if not root:
        return ''
    return postorder(root.left) + postorder(root.right) + root.id

while True:
    try:
        p, i = map(str, input().split())
        preorder = list(p)
        inorder = list(i)
        root = prase_tree(preorder, inorder)
        ans = postorder(root)
        print(ans)
    except EOFError:
        break
```

### 01426: Find The Multiple

http://cs101.openjudge.cn/practice/01426/

要求用bfs实现



思路：从一个1开始往后添0和1，每次添完判断一下能不能被整除。



代码

```python
from collections import deque

def bfs(n,queue):
    while queue:
        num_str = queue.popleft()
        num = int(num_str)
        if num % n == 0:
            return num
        else:
            for i in ['0', '1']:
                num_str1 = num_str + i
                queue.append(num_str1)

while True:
    n = int(input())
    if n == 0:
        break
    else:
        queue = deque(['1'])
        ans = bfs(n,queue)
        print(ans)

```

### 04115: 鸣人和佐助

bfs, http://cs101.openjudge.cn/practice/04115/



思路：重点是在visited数组里面多维护一个T，题解的代码可以掌握，接下来再找找自己的代码一开始错在哪里



代码

```python
from collections import deque

M,N,T = map(int,input().split())
map = [list(input()) for _ in range(M)]
di = [(0,1),(0,-1),(1,0),(-1,0)]
for i in range(M):
    for j in range(N):
        if map[i][j] == '@':
            start = (i,j)


def bfs():
    q = deque([start + (T,0)])
    visited = [[-1]*N for _ in range(M)]
    visited[start[0]][start[1]] = T
    while q:
        x,y,t,time = q.popleft()
        time += 1
        for dx,dy in di:
            if 0 <= x+dx < M and 0 <= y+dy < N:
                if map[x+dx][y+dy] == '*' and t > visited[x+dx][y+dy]:
                    visited[x+dx][y+dy] = t
                    q.append((x+dx,y+dy,t,time))
                elif map[x+dx][y+dy] == '#' and t-1 > visited[x+dx][y+dy]:
                    visited[x+dx][y+dy] = t-1
                    q.append((x+dx,y+dy,t-1,time))
                elif map[x+dx][y+dy] == '+':
                    return time
    return -1

print(bfs())

```



### 20106: 走山路

Dijkstra, http://cs101.openjudge.cn/practice/20106/



思路：bfs+heap，每次取的时候先取消耗体力最小的走法。



代码

```python
import heapq

dx = [0,0,1,-1]
dy = [1,-1,0,0]
def can_get(x,y):
    return 0<=x<m and 0<=y<n and not in_queue[x][y] and matrix[x][y] != '#'

def bfs(start,end):
    hps = []
    queue = ([start])
    heapq.heapify(queue)
    while queue:
        hp, x, y, height = heapq.heappop(queue)
        in_queue[x][y] = True
        if (x, y) == end:
            hps.append(hp)
            break
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if can_get(nx,ny):
                new_hp = hp + abs(height - int(matrix[nx][ny]))
                new_height = int(matrix[nx][ny])
                heapq.heappush(queue,(new_hp,nx,ny,new_height))
    if len(hps) == 0:
        return 'NO'
    else:
        return hps[0]

m,n,p = map(int,input().split())
matrix = [list(map(str,input().split())) for _ in range(m)]
ans = []
for _ in range(p):
    in_queue = [[False]*n for _ in range(m)]
    x1,y1,x2,y2 = map(int,input().split())
    if matrix[x1][y1] == '#' or matrix[x2][y2] == '#':
        ans.append('NO')
        continue
    start = (0,x1,y1,int(matrix[x1][y1]))
    end = (x2,y2)
    ans.append(bfs(start,end))
for _ in range(p):
    print(ans[_])

```

### 05442: 兔子与星空

Prim, http://cs101.openjudge.cn/practice/05442/



思路：用prim实现最小生成树



代码

```python
import heapq

def prim(graph,start):
    mst = []
    used = set([start])
    edges = [(cost,start,to) for to,cost in graph[start].items()]
    heapq.heapify(edges)

    while edges:
        cost,frm,to = heapq.heappop(edges)
        if to not in used:
            used.add(to)
            mst.append((frm,to,cost))
            for next_to,next_cost in graph[to].items():
                if next_to not in used:
                    heapq.heappush(edges,(next_cost,to,next_to))

    return mst

def solve():
    n = int(input())
    graph = {chr(i+65):{} for i in range(n)}
    for i in range(n-1):
        data = input().split()
        star = data[0]
        m = int(data[1])
        for j in range(m):
            to_star = data[2+j*2]
            cost = int(data[3+j*2])
            graph[star][to_star] = cost
            graph[to_star][star] = cost
    mst = prim(graph,'A')
    print(sum(x[2] for x in mst))

solve()

```

## assignmentB

### 28170: 算鹰

dfs, http://cs101.openjudge.cn/practice/28170/



思路：数连通区域的个数。但是我觉得这个题题目描述不合理，按照AC代码，在棋盘上只落了一个子的时候有一个鹰，但这似乎不满足题目中所说的“上下左右四个方向连成一个整体”



代码

```python
matrix = [input() for _ in range(10)]
visited = set()
count = 0
di = [(1,0),(-1,0),(0,1),(0,-1)]
def dfs(x,y):
    visited.add((x,y))
    for dx,dy in di:
        nx = x + dx
        ny = y + dy
        if 0 <= nx <= 9 and 0 <= ny <= 9 and (nx,ny) not in visited and matrix[nx][ny] == '.':
            dfs(nx,ny)
for i in range(10):
    for j in range(10):
        if matrix[i][j] == '.' and (i,j) not in visited:
            dfs(i,j)
            count += 1
print(count)

```

### 02754: 八皇后

dfs, http://cs101.openjudge.cn/practice/02754/



思路：dfs经典例题



代码

```python
ans = []
def dfs(A,cur = 0):
    if cur == len(A):
        ans.append(''.join([str(x+1) for x in A]))
        return
    for col in range(len(A)):
        for row in range(cur):
            if A[row] == col or abs(col - A[row]) == cur - row:
                break
        else:
            A[cur] = col
            dfs(A,cur+1)

dfs([None]*8)
for _ in range(int(input())):
    print(ans[int(input()) - 1])

```



### 03151: Pots

bfs, http://cs101.openjudge.cn/practice/03151/



思路：一个普通的bfs问题，在deque里面多记录一个路径就可以了



代码

```python
def bfs(A,B,C):
    start = (0,0)
    deque=[(start,[])]
    vis.add(start)
    while deque:
        (cx,cy),actions = deque.pop(0)
        if cx == C or cy == C:
            return actions
        for i in range(6):
            if i == 0:
                if (A,cy) not in vis:
                    deque.append(((A,cy),actions+['FILL(1)']))
                    vis.add((A,cy))
            elif i == 1:
                if (cx,B) not in vis:
                    deque.append(((cx,B),actions+['FILL(2)']))
                    vis.add((cx,B))
            elif i == 2:
                if (0,cy) not in vis:
                    deque.append(((0,cy),actions+['DROP(1)']))
                    vis.add((0,cy))
            elif i == 3:
                if (cx,0) not in vis:
                    deque.append(((cx,0),actions+['DROP(2)']))
                    vis.add((cx,0))
            elif i == 4:
                if (min(cx+cy,A),max(0,cx+cy-A)) not in vis:
                    deque.append(((min(cx+cy,A),max(0,cx+cy-A)),actions+['POUR(2,1)']))
                    vis.add((min(cx+cy,A),max(0,cx+cy-A)))
            else:
                if (max(0,cx+cy-B),min(cx+cy,B)) not in vis:
                    deque.append(((max(0,cx+cy-B),min(cx+cy,B)),actions+['POUR(1,2)']))
                    vis.add((max(0,cx+cy-B),min(cx+cy,B)))
    return ['impossible']


vis = set()
A,B,C = map(int,input().split())
ans = bfs(A,B,C)
if ans == ['impossible']:
    print(ans[0])
else:
    print(len(ans))
    for i in ans:
        print(i)

```



### 05907: 二叉树的操作

http://cs101.openjudge.cn/practice/05907/



思路：似乎是比较直接的一个问题，关键是要区分交换的两个子树是否有同样的父节点



代码

```python
class Node():
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None


t = int(input())
for _ in range(t):
    n,m = map(int,input().split())
    nodes = [Node(x) for x in range(n)]
    for __ in range(n):
        x,y,z = map(int,input().split())
        if y != -1:
            nodes[x].left = nodes[y]
            nodes[y].parent = nodes[x]
        if z != -1:
            nodes[x].right = nodes[z]
            nodes[z].parent = nodes[x]
    for __ in range(m):
        s = input()
        if s[0] == '1':
            op,node1,node2 = map(int,s.split())
            tree1,tree2 = nodes[node1],nodes[node2]
            father1 = tree1.parent
            father2 = tree2.parent
            if father1 == father2:
                father2.left,father2.right = father2.right,father2.left
            else:
                if father1.left == tree1:
                    father1.left = tree2
                else:
                    father1.right = tree2

                if father2.left == tree2:
                    father2.left = tree1
                else:
                    father2.right = tree1
                tree1.parent,tree2.parent = father2,father1
        else:
            op,a = map(int,s.split())
            node = nodes[a]
            while node.left:
                node = node.left
            print(node.val)

```

### 18250: 冰阔落 I

Disjoint set, http://cs101.openjudge.cn/practice/18250/



思路：经debug后的find函数可以及时更新x的father，但我不知道为什么之前的错误代码会RE（大概是爆栈）而不是WA，自己造了一些可能导致死循环的数据好像也没发现问题



代码

```python
def find(x):
    if fa[x] != x:
        fa[x] = find(fa[x])
    return fa[x]


def union(x,y):
    fx = find(x)
    fy = find(y)
    if fx == fy:
        return
    fa[fy] = fx


while True:
    try:
        n,m = map(int,input().split())
        fa = [x for x in range(n+1)]
        for _ in range(m):
            x,y = map(int,input().split())
            if find(x) == find(y):
                print('Yes')
            else:
                print('No')
                union(x,y)
        parents = set(find(x) for x in range(1,n+1))
        ans = sorted(parents)
        print(len(ans))
        print(*ans)
    except EOFError:
        break

```

### 05443: 兔子与樱花

http://cs101.openjudge.cn/practice/05443/

思路：dijkstra算法，需要多记录一个路径，图里面字典真是个好东西

代码

```python
import heapq
import math


def Dijkstra(graph,start,end):
    if start == end:
        return []
    distence = {i:(math.inf,[]) for i in graph}
    distence[start] = (0,[start])
    pos = []
    heapq.heappush(pos,(0,start,[]))
    while pos:
        dist1,current_place,path = heapq.heappop(pos)
        for (next_place,dist2) in graph[current_place].items():
            if dist1 + dist2 < distence[next_place][0]:
                distence[next_place] = (dist1 + dist2,path+[next_place])
                heapq.heappush(pos,(dist1 + dist2,next_place,path+[next_place]))
    return distence[end][1]

P = int(input())
graph = {input():{} for _ in range(P)}
Q = int(input())
for _ in range(Q):
    place1,place2,dist = input().split()
    graph[place1][place2] = int(dist)
    graph[place2][place1] = int(dist)
R = int(input())
for _ in range(R):
    start,end = input().split()
    path = Dijkstra(graph,start,end)
    s = start
    current = start
    for i in path:
        s += f'->({graph[current][i]})->{i}'
        current = i
    print(s)

```

## assignmentD

### 02808: 校门外的树

http://cs101.openjudge.cn/practice/02808/



思路：上个学期计概开学考试的题，思路基本上是一样的，范围里面有1就改成0



代码

```python
L,M = map(int,input().split())
trees = [1 for _ in range(L+1)]
for _ in range(M):
    a,b = map(int,input().split())
    for i in range(a,b+1):
        if trees[i] == 1:
            trees[i] = 0
print(sum(trees))

```



### 20449: 是否被5整除

http://cs101.openjudge.cn/practice/20449/



思路：比较直接地翻译了题目，二进制转化为十进制之后直接判断，应该还有更好的办法



代码

```python
def trans(s):
    ans = 0
    for i in range(len(s)):
        ans += int(s[i]) * (2**(len(s)-i))
    return ans

s = input()
res = ''
tmp = ''
for i in range(len(s)):
    tmp += s[i]
    num = trans(tmp)
    if num % 5 == 0:
        res += '1'
    else:
        res += '0'
print(res)
```



### 01258: Agri-Net

http://cs101.openjudge.cn/practice/01258/



思路：和作业中的那个prim问题如出一辙，注意输入可能有多组数据



代码

```python
import heapq


def prim(G,start_node):
    mst = set()
    vis = set([start_node])
    edges = [(cost,start_node,to) for to,cost in G[start_node].items()]
    heapq.heapify(edges)

    while edges:
        cost,frm,to = heapq.heappop(edges)
        if to not in vis:
            vis.add(to)
            mst.add((cost,frm,to))
            for next_to,cost1 in G[to].items():
                heapq.heappush(edges,(cost1,to,next_to))

    return mst

while True:
    try:
        N = int(input())
    except EOFError:
        break

    G = {i:{} for i in range(N)}
    ma = []
    for i in range(N):
        ma.append(list(map(int,input().split())))

    for i in range(N):
        for j in range(N):
            G[i][j] = ma[i][j]

    mst = prim(G,0)
    total = sum(cost for cost,frm,to in mst)

    print(total)

```



### 27635: 判断无向图是否连通有无回路(同23163)

http://cs101.openjudge.cn/practice/27635/



思路：研究笔试代码最有用的一次，昨天补全的代码用上了



代码

```python
def isConnected(G):
    n = len(G)
    visited = [False for _ in range(n)]
    total = 0

    def dfs(v):
        nonlocal total
        visited[v] = True
        total += 1
        for u in G[v]:
            if not visited[u]:
                dfs(u)

    dfs(0)
    return total == n


def hasloop(G):
    n = len(G)
    visited = [False for _ in range(n)]

    def dfs(v,x):
        visited[v] = True
        for u in G[v]:
            if visited[u]:
                if u != x:
                    return True
            else:
                if dfs(u,v):
                    return True
        return False

    for i in range(n):
        if not visited[i]:
            if dfs(i,-1):
                return True
    return False


n,m = map(int,input().split())
G = [[]for _ in range(n)]
for _ in range(m):
    u,v = map(int,input().split())
    G[u].append(v)
    G[v].append(u)

if isConnected(G):
    print('connected:yes')
else:
    print('connected:no')

if hasloop(G):
    print('loop:yes')
else:
    print('loop:no')

```

### 27947: 动态中位数

http://cs101.openjudge.cn/practice/27947/



思路：通过同时维护两个堆保证最大堆的顶部始终是中位数



代码

```python
import heapq

def dynamic_midium(nums):
    left_heap = []
    right_heap = []

    mediums = []
    for i,num in enumerate(nums):
        if not left_heap or num <= -left_heap[0]:
            heapq.heappush(left_heap,-num)
        else:
            heapq.heappush(right_heap,num)

        if len(left_heap) - len(right_heap) > 1:
            heapq.heappush(right_heap,-heapq.heappop(left_heap))
        elif len(right_heap) > len(left_heap):
            heapq.heappush(left_heap,-heapq.heappop(right_heap))

        if i % 2 == 0:
            mediums.append(-left_heap[0])

    return mediums

T = int(input())
for _ in range(T):
    nums = list(map(int,input().split()))
    mediums = dynamic_midium(nums)
    print(len(mediums))
    print(*mediums)


```



### 28190: 奶牛排队

http://cs101.openjudge.cn/practice/28190/



思路：对着题解写完了，还在努力理解单调栈，感觉比T1思考量大了不少



代码

```python
N = int(input())
heights = [int(input()) for _ in range(N)]

left_bound = [-1] * N
right_bound = [N] * N

stack = []

for i in range(N):
    while stack and heights[stack[-1]] < heights[i]:
        stack.pop()

    if stack:
        left_bound[i] = stack[-1]

    stack.append(i)

stack = []

for i in range(N-1,-1,-1):
    while stack and heights[stack[-1]] > heights[i]:
        stack.pop()
    if stack:
        right_bound[i] = stack[-1]

    stack.append(i)

ans = 0

for i in range(N):
    for j in range(left_bound[i] + 1,i):
        if right_bound[j] > i:
            ans = max(ans,i - j + 1)
            break
print(ans) 

```

## assignmentF

### 22485: 升空的焰火，从侧面看

http://cs101.openjudge.cn/practice/22485/



思路：在正常的层次遍历基础上多记录一个高度，遍历的时候把同高度的点存到一起，最后挑出来每一层最后进去的那个



代码

```python
from collections import defaultdict
from collections import deque

lis = defaultdict(list)
class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None


def bfs(lis,nodes):
    deq = deque([(1,0)])
    ans = []
    while deq:
        node,height = deq.popleft()
        lis[height].append(node)
        if nodes[node-1].left:
            deq.append((nodes[node-1].left.val+1,height+1))
        if nodes[node-1].right:
            deq.append((nodes[node-1].right.val+1,height+1))
    key_lis = list(lis.keys())
    for i in sorted(key_lis):
        ans.append(lis[i][-1])
    return ans


N = int(input())
nodes = [Node(i) for i in range(N)]
for i in range(N):
    a,b = map(int,input().split())
    if a != -1:
        nodes[i].left = nodes[a-1]
    if b != -1:
        nodes[i].right = nodes[b-1]
ans = bfs(lis,nodes)
print(*ans)

```



### 28203:【模板】单调栈

http://cs101.openjudge.cn/practice/28203/



思路：非常纯粹的模板



代码

```python
n = int(input())
a = list(map(int,input().split()))
stack = []

for i in range(n):
    while stack and a[stack[-1]] < a[i]:
        a[stack.pop()] = i + 1
    stack.append(i)

while stack:
    a[stack[-1]] = 0
    stack.pop()

print(*a)

```



### 09202: 舰队、海域出击！

http://cs101.openjudge.cn/practice/09202/



思路：用拓扑排序判断有没有环



代码

```python
from collections import deque
from collections import defaultdict
def topo_sort(graph):
    in_degree = {u:0 for u in range(1,n+1)}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    queue = deque([u for u in in_degree if in_degree[u] == 0])
    topo_order = []
    while queue:
        u = queue.popleft()
        topo_order.append(u)
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    if len(topo_order) != len(graph):
        return 'Yes'
    return 'No'


for _ in range(int(input())):
    n,m = map(int,input().split())
    graph = defaultdict(list)
    for __ in range(m):
        u,v = map(int,input().split())
        graph[u].append(v)
    print(topo_sort(graph))

```



### 04135: 月度开销

http://cs101.openjudge.cn/practice/04135/



思路：一道经典的二分查找问题



代码

```python
n,m = map(int,input().split())
ex = []
for _ in range(n):
    ex.append(int(input()))


def check(x):
    num,s = 1,0
    for i in range(n):
        if s + ex[i] > x:
            s = ex[i]
            num += 1
        else:
            s += ex[i]
    if num > m:
        return True
    return False

lo = max(ex)
hi = sum(ex) + 1
ans = 1
while lo < hi:
    mid = (lo + hi) // 2
    if check(mid):
        lo = mid + 1
    else:
        ans = mid
        hi = mid

print(ans)# 

```





### 07735: 道路

http://cs101.openjudge.cn/practice/07735/



思路：一道明显的dijkstra，但是不用维护visit数组



代码

```python
import heapq


def dijkstra(graph,n):
    heap = [(0,0,0)]
    while heap:
        dist,node,fee = heapq.heappop(heap)
        if node == n-1:
            return dist
        for nnode,ndist,nfee in graph[node]:
            if fee + nfee <= k:
                heapq.heappush(heap,(dist + ndist,nnode,fee + nfee))
    return -1

k = int(input())
n = int(input())
r = int(input())
graph = [[] for _ in range(n)]
for i in range(r):
    s,d,l,t = map(int,input().split())
    graph[s-1].append((d-1,l,t))

print(dijkstra(graph,n))


```

### 01182: 食物链

http://cs101.openjudge.cn/practice/01182/



思路：并查集，自己没想明白怎么把这个循环关系搞好，参考了一下题解里面的第二种写法



代码

```python
def find(x):
    if p[x] == x:
        return x
    else:
        p[x] = find(p[x])
        return p[x]


n,k = map(int,input().split())
p = [i for i in range(3*n+1)]
ans = 0
for _ in range(k):
    a,x,y = map(int,input().split())
    if x > n or y > n:
        ans += 1
        continue
    if a == 1:
        if find(x+n) == find(y) or find(y+n) == find(x):
            ans += 1
            continue
        else:
            p[find(x)] = find(y)
            p[find(x+n)] = find(y+n)
            p[find(x+2*n)] = find(y+2*n)
    else:
        if find(x) == find(y) or find(y+n) == find(x):
            ans += 1
            continue
        else:
            p[find(x+n)] = find(y)
            p[find(y+2*n)] = find(x)
            p[find(x+2*n)] = find(y+n)
print(ans)

```

## 每日选做

### 01941:The Sierpinski Fractal

http://cs101.openjudge.cn/2024sp_routine/01941/

```python
def f(n):
    if n == 1:
        return [' /\\ ', '/__\\']
    t = f(n - 1)
    x = 2 ** (n - 1)
    res = [' ' * x + u + ' ' * x for u in t]
    res.extend([u + u for u in t])
    return res


al = [f(i) for i in range(1, 11)]
while True:
    n = int(input())
    if n == 0:
        break
    for u in al[n - 1]:
        print(u)
    print()
```

### 02386:Lake Counting

http://cs101.openjudge.cn/2024sp_routine/02386/

```python
import sys
sys.setrecursionlimit(20000)
def dfs(x,y):
    matrix[x][y] = '.'
    for k in range(8):
        nx = x + dx[k]
        ny = y + dy[k]
        if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 'W':
            dfs(nx,ny)

n,m = map(int,input().split())
matrix = [list(input()) for _ in range(n)]
dx = [-1,-1,-1,0,0,1,1,1]
dy = [-1,0,1,-1,1,-1,0,1]
ans = 0
for i in range(n):
    for j in range(m):
        if matrix[i][j] == 'W':
            dfs(i,j)
            ans += 1
print(ans)
```

### 02499:Binary Tree

http://cs101.openjudge.cn/2024sp_routine/02499/

```python
n = int(input())
for i in range(n):
    a, b = map(int,input().split())
    l, r = 0, 0
    while a != 1 or b != 1:
        if a == 1:
            r += b - a
            b = 1
        elif b == 1:
            l += a - 1
            a = 1
        elif a > b:
            l += a //b
            a -= b * (a//b)
        elif a < b:
            r += b // a
            b -= a * (b//a)
    print(f'Scenario #{i+1}:')
    print(l, r)
    print()
```

### 02733:判断闰年

http://cs101.openjudge.cn/2024sp_routine/02733/

```python
import calendar
n = int(input())
if calendar.isleap(n):
    print('Y')
else:
    print('N')
```

### 02734:十进制到八进制

http://cs101.openjudge.cn/2024sp_routine/02734/

```python
def ten_to_eight(num):
    lis = []
    if num == 0:
        return 0
    while num > 0:
        lis.append(num % 8)
        num = num // 8

    res = ''
    while lis:
        res += str(lis.pop())
    return res

print(ten_to_eight(int(input())))
```

### 02760:数字三角形

http://cs101.openjudge.cn/2024sp_routine/02760/

```python
n = int(input())
nums = []
sums = [[]for _ in range(n)]

for i in range(n):
    nums.append(list(map(int,input().split())))


for i in range(n):
    if i == 0:
        sums[0].append(nums[0][0])
    else:
        for j in range(i+1):
            if j == 0:
                sums[i].append(sums[i-1][j]+nums[i][j])
            elif j == i:
                sums[i].append(sums[i-1][j-1]+nums[i][j])
            else:
                sums[i].append(max(sums[i-1][j-1]+nums[i][j],sums[i-1][j]+nums[i][j]))
print(max(sums[n-1]))
```

### 02783:Holiday Hotel

http://cs101.openjudge.cn/2024sp_routine/02783/

```python
while True:
    n = int(input())
    if n == 0:
        break
    hotels = [tuple(map(int,input().split())) for _ in range(n)]
    res = 1
    hotels.sort(key=lambda x:(x[0],x[1]))
    macost = hotels[0][1]
    for i in range(1,n):
        if hotels[i][1] < macost:
            res += 1
            macost = hotels[i][1]
    print(res)
```

### 03424:Candies

http://cs101.openjudge.cn/2024sp_routine/03424/

```python
import heapq

def dijkstra(N, G, start):
    INF = float('inf')
    dist = [INF] * (N + 1)
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        d, node = heapq.heappop(pq)
        if d > dist[node]:
            continue
        for neighbor, weight in G[node]:
            new_dist = dist[node] + weight
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))
    return dist



N, M = map(int, input().split())
G = [[] for _ in range(N + 1)]
for _ in range(M):
    s, e, w = map(int, input().split())
    G[s].append((e, w))


start_node = 1
shortest_distances = dijkstra(N, G, start_node)
print(shortest_distances[-1])
```

### 04067:回文数字（Palindrome Number）

http://cs101.openjudge.cn/2024sp_routine/04067/

```python
while True:
    try:
        flag = True
        num = int(input())
        num = str(num)
        if len(num) % 2 != 0:
            if len(num) == 1:
                print('YES')
                continue
            else:
                for i in range(len(num)//2):
                    if num[i] == num[-i-1]:
                        continue
                    else:
                        flag = False
                        break
        else:
            for i in range(len(num)//2):
                if num[i] == num[-i-1]:
                    continue
                else:
                    flag = False
                    break
        if flag:
            print('YES')
        else:
            print('NO')
    except EOFError:
        break
```

### 04084:拓扑排序

http://cs101.openjudge.cn/2024sp_routine/04084/

```python
import heapq

def toposort(ver,edges):
    in_edges = [0] * (ver + 1)
    connect = [[0]*(ver + 1) for _ in range(ver + 1)]

    for u,v in edges:
        in_edges[v] += 1
        connect[u][v] += 1

    queue = []
    for i in range(1,ver+1):
        if in_edges[i] == 0:
            heapq.heappush(queue,i)

    order = []

    while queue:
        u = heapq.heappop(queue)
        order.append(u)
        for v in range(1,ver + 1):
            if connect[u][v] > 0:
                in_edges[v] -= connect[u][v]
                if in_edges[v] == 0:
                    heapq.heappush(queue,v)

    if len(order) == ver:
        return order
    else:
        return None

ver,num_edges = map(int,input().split())
edges = []
for _ in range(num_edges):
    u,v = map(int,input().split())
    edges.append((u,v))
order = toposort(ver,edges)
if order:
    for i,ver in enumerate(order):
        if i < len(order) - 1:
            print(f'v{ver}',end = ' ')
        else:
            print(f'v{ver}')
else:
    print('No topological order exists due to a cycle in the graph.')
```

### 04099:队列和栈

http://cs101.openjudge.cn/2024sp_routine/04099/

```python
m = int(input())
for _ in range(m):
    flag = False
    n = int(input())
    q = []
    s = []
    for __ in range(n):
        a = input()
        if a == 'pop':
            if not q:
                flag = True
                continue
            else:
                q.pop(0)
                s.pop()
        else:
            a,b = a.split()
            q.append(int(b))
            s.append(int(b))
    if flag:
        print('error')
        print('error')
    else:
        print(' '.join(map(str,q)))
        print(' '.join(map(str,s)))
```

### 04146:数字方格

http://cs101.openjudge.cn/2024sp_routine/04146/

```python
n = int(input())
res = []
for a1 in range(0,n+1):
    for a2 in range(0,n+1):
        for a3 in range(0,n+1):
            if (a1 + a2) % 2 == 0 and (a2 + a3) % 3 == 0 and (a1 + a2 + a3) % 5 == 0:
                res.append(a1 + a2 + a3)
print(max(res))
```

### 05345:位查询

http://cs101.openjudge.cn/2024sp_routine/05345/

```python
N, M = map(int,input().split())
nums = list(map(int,input().split()))
ans = []
for i in range(M):
    a, b = map(str,input().split())
    if a == 'C':
        for j in range(N):
            nums[j] += 1
            if nums[j] > 65535:
                nums[j] %= 65536
    elif a == 'Q':
        count = 0
        c = int(b) + 1
        for j in nums:
            if len(bin(j)[2:]) < c:
                continue
            if bin(j)[-c] != '0':
                count += 1
        ans.append(count)
for i in ans:
    print(i)
```

### 07745:整数奇偶排序

http://cs101.openjudge.cn/2024sp_routine/07745/

```python
nums = list(map(int,input().split()))
lis1 = []
lis2 = []
for i in nums:
    if i % 2 != 0:
        lis1.append(i)
    else:
        lis2.append(i)
lis1.sort(reverse=True)
lis2.sort()
lis = lis1 + lis2
for i in lis:
    print(i,end=' ' )
```

### 08210:河中跳房子

http://cs101.openjudge.cn/2024sp_routine/08210/

```python
L,N,M = map(int,input().split())
rock = [0]
for _ in range(N):
    rock.append(int(input()))
rock.append(L)

def check(n):
    num = 0
    point = 0
    for i in range(1,N+2):
        if rock[i] - point < n:
            num += 1
        else:
            point = rock[i]
    if num > M:
        return True
    else:
        return False

left = 0
right = L+1
ans = -1
while left<right:
    mid = (left+right)//2
    if check(mid):
        right = mid
    else:
        ans = mid
        left = mid + 1
print(ans)
```

### 09201:Freda的越野跑

http://cs101.openjudge.cn/2024sp_routine/09201/

```python
def merge_sort(lis):
    if len(lis) <= 1:
        return lis,0
    mid = len(lis) // 2
    left,inv_left = merge_sort(lis[:mid])
    right,inv_right = merge_sort(lis[mid:])
    merged,inv_merge = merge(left,right)

    return merged,inv_merge+inv_left+inv_right

def merge(left,right):
    merged = []
    inv_count = 0
    i,j = 0,0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            inv_count += len(left) - i

    merged += left[i:]
    merged += right[j:]
    return merged,inv_count

n = int(input())
lis = list(map(int,input().split()))
lis_1 = []
for i in range(n-1,-1,-1):
    lis_1.append(lis[i])
merged,ans = merge_sort(lis_1)
print(ans)
```

### 12876:生理周期

http://cs101.openjudge.cn/2024sp_routine/12876/

```python
case_num = 0
while True:
    p,e,i,d = map(int,input().split())
    if p == -1 and e == -1 and i == -1 and d == -1:
        break
    case_num += 1
    for j in range(d + 1,30000):
        if (j - p) % 23 == 0 and (j - e) % 28 == 0 and (j-i) % 33 == 0:
            res = j - d
            break
    print(f'Case {case_num}: the next triple peak occurs in {res} days.')
```

### 18164:剪绳子

http://cs101.openjudge.cn/2024sp_routine/18164/

```python
import heapq

N = int(input())
length = list(map(int,input().split()))

heapq.heapify(length)
ans = 0
for i in range(N-1):
    a = heapq.heappop(length)
    b = heapq.heappop(length)
    c = a + b
    heapq.heappush(length,c)
    ans += c
print(ans)
```

### 19930:寻宝

http://cs101.openjudge.cn/2024sp_routine/19930/

```python
from collections import deque

dx = [0,0,1,-1]
dy = [1,-1,0,0]

def can_get(x,y):
    return 0<= x < m and 0 <= y < n and matrix[x][y] !=2 and not in_queue[x][y]
def bfs(i,j):
    queue = deque()
    queue.append((i,j))
    in_queue[i][j] = True
    step = 0
    while queue:
        for _ in range(len(queue)):
            cur_i,cur_j = queue.popleft()
            if matrix[cur_i][cur_j] == 1:
                return step
            else:
                for i in range(4):
                    nexti = cur_i + dx[i]
                    nextj = cur_j + dy[i]
                    if can_get(nexti,nextj):
                        queue.append((nexti,nextj))
                        in_queue[nexti][nextj] = True
        step += 1
    return 'NO'

m,n = map(int,input().split())
in_queue = [[False]*n for _ in range(m)]
matrix = [list(map(int,input().split())) for _ in range(m)]
step = bfs(0,0)
print(step)
```

### 20018:蚂蚁王国的越野跑

http://cs101.openjudge.cn/2024sp_routine/20018/

```python
def merge_sort(lis):
    if len(lis) <= 1:
        return lis,0
    mid = len(lis) // 2
    left,inv_left = merge_sort(lis[:mid])
    right,inv_right = merge_sort(lis[mid:])
    merged,inv_merge = merge(left,right)

    return merged,inv_merge+inv_left+inv_right

def merge(left,right):
    merged = []
    inv_count = 0
    i,j = 0,0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
            inv_count += len(left) - i

    merged += left[i:]
    merged += right[j:]
    return merged,inv_count

n = int(input())
lis = [int(input()) for _ in range(n)]
lis_1 = []
for i in range(n-1,-1,-1):
    lis_1.append(lis[i])
merged,ans = merge_sort(lis_1)
print(ans)
```

### 20449:是否被5整除

http://cs101.openjudge.cn/2024sp_routine/20449/

```python
A = input()
res = ''
for i in range(1,len(A) + 1):
    if int(A[:i],2) % 5 == 0:
        res += '1'
    else:
        res += '0'
print(res)
```

### 21759:P大卷王查询系统

http://cs101.openjudge.cn/2024sp_routine/21759/

```python
n,x,y = map(int,input().split())
l_dic = {}
s_dic = {}
for i in range(n):
    lesson,name,score = map(str,input().split())
    if name not in l_dic.keys():
        l_dic[name] = [lesson]
        s_dic[name] = [int(score)]
    else:
        l_dic[name].append(lesson)
        s_dic[name].append(int(score))
m = int(input())
for j in range(m):
    search = input()
    length = len(l_dic[search])
    if length >= x and sum(s_dic[search])/length > y:
        print('yes')
    else:
        print('no')
```

### 22460:火星车勘探

http://cs101.openjudge.cn/2024sp_routine/22460/

```python
class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None

def prase_tree(s):
    root = Node(s.pop())
    if root.val != '#':
        root.left = prase_tree(s)
        root.right = prase_tree(s)
    return root


while True:
    try:
        n = int(input())
        if n == 0:
            break
        s = input().split()[::-1]
        _ = prase_tree(s)
        # print(s)
        print('F' if len(s) else 'T')
    except IndexError:
        print('F')
```

### 22642:括号生成

http://cs101.openjudge.cn/2024sp_routine/22642/

```python
def add(n,left,right,string):
    if left == n and right == n:
        print(string)
        return
    if left < n:
        add(n,left+1,right,string+'(')
    if right < left:
        add(n,left,right + 1,string + ')')
n = int(input())
add(n,0,0,'')
```

### 24588:后序表达式求值

http://cs101.openjudge.cn/2024sp_routine/24588/

```python
def count_profix(expression):
    profix = list(expression.split())
    stack = []
    while profix:
        # print(stack)
        a = profix.pop(0)
        if a in '+-*/':
            b = stack.pop()
            c = stack.pop()
            if a == '+':
                stack.append(b+c)
            elif a == '-':
                stack.append(c-b)
            elif a == '*':
                stack.append(b*c)
            else:
                stack.append(c/b)
        else:
            stack.append(float(a))
    return stack[0]

n = int(input())
for _ in range(n):
    expression = input()
    print(f'{count_profix(expression):.2f}')
```

### 25145:猜二叉树

http://cs101.openjudge.cn/2024sp_routine/25145/

```python
from collections import deque

class TreeNode:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None

def prase_tree(inorder,postorder):
    if inorder:
        root_letter = postorder.pop()
        root = TreeNode(root_letter)
        root_index = inorder.index(root_letter)

        root.right = prase_tree(inorder[root_index+1:],postorder)
        root.left = prase_tree(inorder[:root_index],postorder)

        return root

def levelorder(root):
    if root is None:
        return []
    res = []
    deq = deque([root])
    while deq:
        node = deq.popleft()
        res.append(node.val)
        if node.left:
            deq.append(node.left)
        if node.right:
            deq.append(node.right)
    return res

n = int(input())
for _ in range(n):
    inorder = list(input())
    postorder = list(input())
    root = prase_tree(inorder,postorder)
    print(''.join(levelorder(root)))
```

### 25301:生日相同

http://cs101.openjudge.cn/2024sp_routine/25301/

```python
from collections import defaultdict
bi = defaultdict(list)
n = int(input())
for _ in range(n):
    num,mon,da = map(str,input().split())
    a = (int(mon),int(da))
    bi[a].append(num)
keys_lis = list(bi.keys())
kl2 = [[] for _ in range(13)]
for j in keys_lis:
    kl2[j[0]].append(j[1])
for i in range(1,13):
    kl2[i] = sorted(set(kl2[i]))
    for j in kl2[i]:
        ij = (i,j)
        if len(bi[ij]) > 1:
            print(i,j,' '.join(map(str,bi[ij])))
```

### 27274:字符串提炼

http://cs101.openjudge.cn/2024sp_routine/27274/

```python
import math
s = input()
m = math.floor(math.log(len(s),2))
lis = []
for i in range(m + 1):
    lis.append(s[pow(2,i)-1])
res = ''
if len(lis) % 2 != 0:
    for j in range(len(lis)//2):
        res += lis[j]
        res += lis[-j-1]
    res += lis[len(lis)//2]
else:
    for j in range(len(lis)//2):
        res += lis[j]
        res += lis[-j-1]
print(res)
```

### 27301:给植物浇水

http://cs101.openjudge.cn/2024sp_routine/27301/

```python
n,a,b = map(int,input().split())
plants = list(map(int,input().split()))
left_w = a
right_w = b
ans = 0
if n%2 == 0:
    for left in range(0,n//2):
        if left_w < plants[left]:
            left_w = a
            left_w -= plants[left]
            ans += 1
        elif left_w >= plants[left]:
            left_w -= plants[left]
    for right in range(n-1,n//2-1,-1):
        if right_w < plants[right]:
            right_w = b
            right_w -= plants[right]
            ans += 1
        elif right_w >= plants[right]:
            right_w -= plants[right]
    print(ans)
else:
    for left in range(0,n//2):
        if left_w < plants[left]:
            left_w = a
            left_w -= plants[left]
            ans += 1
        elif left_w >= plants[left]:
            left_w -= plants[left]
    for right in range(n-1,n//2,-1):
        # print(right)
        if right_w < plants[right]:
            right_w = b
            right_w -= plants[right]
            ans += 1
        elif right_w >= plants[right]:
            right_w -= plants[right]
        # print(right_w)
    left = n//2
    if max(left_w,right_w) < plants[left]:
        ans += 1
    print(ans)
```

### 27310:积木

http://cs101.openjudge.cn/2024sp_routine/27310/

```python
from collections import defaultdict

def dfs(word,i):
    global ans
    if i == len(word):
        ans = 'YES'
        return ans
    for j in range(4):
        if word[i] in cube[j] and test[j]:
            test[j] = False
            # print(test)
            dfs(word,i+1)
            test[j] = True
        else:
            continue
    return ans

n = int(input())
cube = defaultdict(str)
test = [True for _ in range(4)]
for _ in range(4):
    cube[_] = input()
for _ in range(n):
    ans = 'NO'
    word = input()
    dfs(word,0)
    print(ans)
```

### 27625:AVL树至少有几个结点

http://cs101.openjudge.cn/2024sp_routine/27625/

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def solve(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return solve(n-2) + solve(n-1) + 1

print(solve(int(input())))
```
